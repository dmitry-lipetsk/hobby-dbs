include(core/inc/common.inc)

CREATE TABLE CORE.OBJECTS
(
 OBJECT_ID       CORE.D_OBJECT_ID NOT NULL,
 OBJECT_CLASS    CORE.D_OBJECT_CLASS NOT NULL,

 OWNER_ID        CORE.D_OBJECT_ID NOT NULL,
 OWNER_CLASS     CORE.D_OBJECT_CLASS NOT NULL,

 CREATE_DATE     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
 CREATOR_ID      CORE.D_OBJECT_ID,
 CREATOR_CLASS   CORE.D_OBJECT_CLASS,

 DESTROY_DATE    TIMESTAMP,
 DESTROYER_ID    CORE.D_OBJECT_ID,
 DESTROYER_CLASS CORE.D_OBJECT_CLASS,

 M4_DEF_OBJECT_PK(CORE_OBJECTS),

 CONSTRAINT FK_OBJECT_TREE
  FOREIGN KEY (OWNER_ID, OWNER_CLASS) REFERENCES CORE.OBJECTS (OBJECT_ID,OBJECT_CLASS),

 FOREIGN KEY (CREATOR_ID, CREATOR_CLASS) REFERENCES CORE.OBJECTS (OBJECT_ID,OBJECT_CLASS),

 FOREIGN KEY (DESTROYER_ID, DESTROYER_CLASS) REFERENCES CORE.OBJECTS (OBJECT_ID,OBJECT_CLASS),

 FOREIGN KEY (OWNER_CLASS, OBJECT_CLASS) REFERENCES CORE.POSSIBLE_OBJECTS_LINKS (OWNER_CLASS, CHILD_CLASS)
);/*TABLE OBJECTS*/

M4_REG_TABLE_NAME1(CORE_OBJECTS);

M4_REG_CLASS(CORE_OBJECTS,CORE_OBJECTS,NULL,NULL,NULL);

M4_REG_POS_OBJ_LINKS(CORE_OBJECTS,CORE_OBJECTS);

INSERT INTO CORE.OBJECTS (OBJECT_ID,OBJECT_CLASS,OWNER_ID,OWNER_CLASS) VALUES(0,CLASSID_CORE_OBJECTS,0,CLASSID_CORE_OBJECTS);

/* ********************************************************************************************** */

CREATE FUNCTION CORE.FN_TR__PREVENT_RECURSION_IN_OBJECTS() RETURNS TRIGGER AS $$
 DECLARE OWNER_ID1    BIGINT;
 DECLARE OWNER_CLASS1 INTEGER;
BEGIN
 OWNER_ID1=NEW.OWNER_ID;
 OWNER_CLASS1=NEW.OWNER_CLASS;

 WHILE(OWNER_ID1<>0 AND OWNER_CLASS1<>0)
 LOOP
  IF(OWNER_ID1=NEW.OBJECT_ID AND OWNER_CLASS1=NEW.OBJECT_CLASS)THEN
   RAISE EXCEPTION 'Рекурсия в дереве объектов.';
  END IF;

  SELECT t.OWNER_ID, t.OWNER_CLASS
  INTO OWNER_ID1, OWNER_CLASS1
  FROM CORE.OBJECTS t
  WHERE t.OBJECT_ID=OWNER_ID1 AND t.OBJECT_CLASS=OWNER_CLASS1;
 END LOOP;

 RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER AU_OBJECTS_CHECK_RECURSION
AFTER INSERT OR UPDATE
ON CORE.OBJECTS
FOR EACH ROW
EXECUTE PROCEDURE CORE.FN_TR__PREVENT_RECURSION_IN_OBJECTS();

/* ********************************************************************************************** */

CREATE FUNCTION CORE.FN_TR__DELETE_OBJECT() RETURNS TRIGGER AS $$
BEGIN
 DELETE FROM CORE.OBJECTS WHERE OBJECT_ID=OLD.OBJECT_ID AND OBJECT_CLASS=OLD.OBJECT_CLASS;
 RETURN OLD; /*allow continue delete operation*/
END;
$$
LANGUAGE plpgsql;

/* ********************************************************************************************** */

CREATE FUNCTION CORE.FN_TR__PREVENT_CHANGE_RO_OBJ() RETURNS TRIGGER AS $$
BEGIN
 IF ((SELECT COUNT(*) FROM CORE.OBJECTS_COMMON_ATTRS WHERE OBJECT_ID=OLD.OBJECT_ID AND OBJECT_CLASS=OLD.OBJECT_CLASS)>0) THEN
  RAISE EXCEPTION 'Объект предназначен только для чтения.';
 END IF;

 IF(TG_OP='UPDATE')THEN
  RETURN NEW; /*allow continue update operation*/
 END IF;

 IF(TG_OP='DELETE')THEN
  RETURN OLD; /*allow continue delete operation*/
 END IF;
END;
$$
LANGUAGE plpgsql;

M4_CREATE_TRIGGER_RO_OBJ_GUARD(CORE_OBJECTS);

/* ********************************************************************************************** */
